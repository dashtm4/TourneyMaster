import { getPaymentPlans } from '../../products/activeProducts.js';
import { loadAll, stripe } from '../common/common';

const createOrUpdateCustomer = async (subData, currency) => {
  const customerData = {
    ...subData.customer,
    metadata: {
      reg_type: subData.reg_type,
      reg_response_id: subData.reg_response_id,
    },
  };
  console.log(customerData);

  let customer;
  const customersList = await stripe.customers.list(
    {
      email: customerData.email,
      limit: 100,
    },
    subData.requestParams
  );

  console.log(
    `Customers with email ${customerData.email}: ${JSON.stringify(
      customersList
    )}. Currency: ${currency}`
  );
  const customers = customersList?.data?.filter(
    customer =>
      !customer.currency ||
      customer.currency.toLowerCase() === currency.toLowerCase()
  );
  console.log(`Customers filtered by currency: ${JSON.stringify(customers)}`);

  if (customers?.length > 0) {
    customer = await stripe.customers.update(
      customers[0].id,
      customerData,
      subData.requestParams
    );
    console.log(`Stripe Customer ${customer.id} updated`);
  } else {
    customer = await stripe.customers.create(
      customerData,
      subData.requestParams
    );
    console.log(`Stripe Customer ${customer.id} created`);
  }

  return customer;
};

const attachPaymentMethod = async (customer, paymentMethodId, subData) => {
  const paymentMethod = await stripe.paymentMethods.attach(
    paymentMethodId,
    {
      customer: customer.id,
    },
    subData.requestParams
  );

  console.log(
    `Stripe PaymentMethod ${paymentMethod.id} attached to customer ${customer.id}`
  );

  await stripe.customers.update(
    customer.id,
    {
      invoice_settings: {
        default_payment_method: paymentMethodId,
      },
    },
    subData.requestParams
  );

  console.log(
    `Stripe PaymentMethod ${paymentMethod.id} set as default customer`
  );
  return paymentMethod;
};

const validateSubscriptionData = async (subData /* price */) => {
  if (subData.reg_type !== 'individual' && subData.reg_type !== 'team') {
    throw new Error('Reg_type must be "individual" or "team"');
  }
};

const createSubscription = async (customer, paymentPlan, subData) => {
  const validatePrice = async price => {
    if (price.unit_amount > process.env.MAX_PAYMENT_AMOUNT * 100) {
      console.error(
        `Payment amount ${
          price.unit_amount / 100
        } is higher than MAX_PAYMENT_AMOUNT=${process.env.MAX_PAYMENT_AMOUNT}`
      );
      throw new Error(
        `Payment amount ${
          price.unit_amount / 100
        } cannot be processed online. Please contact the event organizer.`
      );
    }
  };

  const getPrice = async ({ sku_id, payment_plan_id, stripe_connect_id }) => {
    const requestParams =
      stripe_connect_id === 'main'
        ? null
        : { stripeAccount: stripe_connect_id };
    const prices = (
      await stripe.prices.list({ product: sku_id, active: true }, requestParams)
    ).data;
    console.log(`Prices of sku ${sku_id}`, prices);
    const price = prices.find(x => x.metadata.externalId === payment_plan_id);
    console.log(`Price of ${payment_plan_id}:`, price);
    await validatePrice(price);

    return price;
  };

  const salesTaxRate = paymentPlan.sales_tax_rate
    ? (
        await loadAll(stripe.taxRates, { active: true }, subData.requestParams)
      ).find(tax => +tax.percentage === paymentPlan.sales_tax_rate)
    : null;

  const coupon =
    subData.items[0].discount_code &&
    subData.items[0].discount_code === paymentPlan.promo_code
      ? await (await loadAll(stripe.coupons, null, subData.requestParams)).find(
          coupon => coupon.percent_off === paymentPlan.promo_code_discount
        )
      : null;

  let phases = [];
  let billingCycleAnchor;
  if (paymentPlan.type === 'installment') {
    const price = await getPrice(paymentPlan);
    billingCycleAnchor = paymentPlan.billing_cycle_anchor;

    phases.push({
      plans: [{ price: price.id, quantity: subData.items[0].quantity }],
      iterations: paymentPlan.iterations,
      proration_behavior: 'none',
      application_fee_percent: paymentPlan.application_fee_percent.toFixed(2),
      coupon: coupon?.id,
      default_tax_rates: salesTaxRate ? [salesTaxRate.id] : [],
    });
  } else if (paymentPlan.type === 'schedule') {
    phases = paymentPlan.schedule;

    billingCycleAnchor = paymentPlan.schedule.reduce(
      (a, c) =>
        !a || +c.billing_cycle_anchor < a ? +c.billing_cycle_anchor : a,
      0
    );

    // Find a special price for payment schedule phases (generated by SyncProducts)
    const paymentSchedulePrice = (
      await stripe.prices.list(
        {
          product: `sched_${paymentPlan.currency.toLowerCase()}_${
            paymentPlan.stripe_connect_id
          }`,
          active: true,
        },
        subData.requestParams
      )
    ).data[0];

    phases = await Promise.all(
      phases.map(async (phase, i) => {
        const price = await getPrice({
          sku_id: paymentPlan.sku_id,
          payment_plan_id: phase.price_external_id,
          stripe_connect_id: paymentPlan.stripe_connect_id,
        });

        let add_invoice_items;
        if (coupon) {
          add_invoice_items = [
            {
              // price_data: {
              //   currency: price.currency,
              //   product: price.product,
              //   unit_amount: Math.round(
              //     price.unit_amount // * (1 - coupon.percent_off / 100)
              //   ),
              // },
              price: price.id,
              quantity: subData.items[0].quantity,
            },
          ];
        } else {
          add_invoice_items = [
            {
              price: price.id,
              quantity: subData.items[0].quantity,
            },
          ];
        }

        const t = {
          plans: [{ price: paymentSchedulePrice.id, quantity: 0 }],
          add_invoice_items,
          billing_thresholds: {
            amount_gte: 50,
            reset_billing_cycle_anchor: true,
          },
          end_date: Math.round(
            i < phases.length - 1
              ? +phases[i + 1].date // end_date = start_date of the next installment
              : phase.date === 'now'
              ? new Date().getTime() / 1000 + 60 * 60 * 24 // if the last and only installment end_date = now + 1 day
              : +phase.date + 60 * 60 * 24 // if the last installment end_date = phase.date + 1 day
          ),
          proration_behavior: 'none',
          application_fee_percent: paymentPlan.application_fee_percent.toFixed(
            2
          ),
          coupon: coupon?.id,
          default_tax_rates: salesTaxRate ? [salesTaxRate.id] : [],
        };
        return t;
      })
    );
  } else {
    throw new Error(`Payment plan type ${paymentPlan.type} not supported`);
  }

  const subscriptionScheduleData = {
    customer: customer.id,
    start_date: 'now',
    end_behavior: 'cancel',
    phases,
    metadata: {
      reg_type: subData.reg_type,
      reg_response_id: subData.reg_response_id,
      owner_id: paymentPlan.owner_id,
      event_id: paymentPlan.event_id,
      division_id: paymentPlan.division_id,
      sku_id: paymentPlan.sku_id,
      payment_plan_id: paymentPlan.payment_plan_id,
      promo_code: subData.items[0].discount_code,
    },
    expand: ['subscription.latest_invoice.payment_intent'],
  };

  if (coupon) {
    subscriptionScheduleData.metadata.promo_code_discount =
      paymentPlan.promo_code_discount;
    subscriptionScheduleData.metadata.coupon = coupon.id;
  }

  const schedule = await stripe.subscriptionSchedules.create(
    subscriptionScheduleData,
    subData.requestParams
  );

  console.log(`Stripe Schedule ${schedule.id} created`);

  let subscription = await stripe.subscriptions.update(
    schedule.subscription.id,
    {
      pending_invoice_item_interval: { interval: 'day', interval_count: 1 },
      metadata: { ...subscriptionScheduleData.metadata },
    },
    subData.requestParams
  );

  console.log(`Stripe Subscription ${subscription.id} added metadata`);

  const updatedInvoice = await stripe.invoices.update(
    schedule.subscription.latest_invoice.id,
    {
      footer: paymentPlan.payment_plan_notice
        .split(': ')
        .join(':\n - ')
        .split(',')
        .join('\n -'),
    },
    subData.requestParams
  );

  console.log(`Invoice ${updatedInvoice.id} updated`);

  const invoice = await stripe.invoices.pay(
    schedule.subscription.latest_invoice.id,
    subData.requestParams
  );

  console.log(`Invoice ${invoice.id} attempted payment`);

  subscription = await stripe.subscriptions.retrieve(
    subscription.id,
    {
      expand: ['latest_invoice.payment_intent'],
    },
    subData.requestParams
  );

  return subscription;
};

export const processCreateSubscription = async subData => {
  console.log(`SubData: ${JSON.stringify(subData)}`);

  const paymentPlan = (await getPaymentPlans(subData.items[0]))[0];
  console.log(`Payment Plan: ${JSON.stringify(paymentPlan)}`);
  // const price = await getPrice(subData);
  subData.requestParams =
    paymentPlan.stripe_connect_id === 'main'
      ? null
      : { stripeAccount: paymentPlan.stripe_connect_id };
  await validateSubscriptionData(subData /*, price */);
  const customer = await createOrUpdateCustomer(subData, paymentPlan.currency);
  const paymentMethod = await attachPaymentMethod(
    customer,
    subData.paymentMethodId,
    subData
  );

  const subscription = await createSubscription(
    customer,
    paymentPlan,
    subData /*, price */
  );

  return subscription;
};
